class Utils {

     public static void CopyProjectToDestination(Dictionary<string, string> sourceFilesDictionary, string destinationFolder)
     {
         // Delete destination folder if it exists
         if (Directory.Exists(destinationFolder))
         {
             Directory.Delete(destinationFolder, true);
         }
 
         // Copy files to destination folder
         foreach (var file in sourceFilesDictionary)
         {
             string destinationPath = Path.Combine(destinationFolder, Path.GetFileName(file.Key));
             string destinationDirectory = Path.GetDirectoryName(destinationPath);
 
             // Exclude files generated by compilation steps
             if (destinationPath.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) ||
                 destinationPath.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) ||
                 destinationPath.Contains("\\bin\\", StringComparison.OrdinalIgnoreCase))
             {
                 continue;
             }
 
             if (!Directory.Exists(destinationDirectory))
             {
                 Directory.CreateDirectory(destinationDirectory);
             }
             File.Copy(file.Key, destinationPath, overwrite: true);
         }
     }
 
    public const string COMMENT = "[COMMENT]";
    
    public const string FILE_NAME = "[FILE NAME]";
    
    public const string START_CODE = "[START CODE]";
    public const string END_CODE = "[END CODE]";

    public static string CleanString(string input) {
        return input.Replace("\r\n", "\n");
    }

    // GPT4 has habit of occasionally:
    // 1) Injects commentary with starting with ``` unrelated to the code
    // 2) Putting {no changes} for code that has no changes
    public static int NextNonBlankIndex(string[] lines, int currentIndex) {
        while (string.IsNullOrWhiteSpace(lines[currentIndex]) 
        || string.Equals(lines[currentIndex], "{no changes}", StringComparison.CurrentCultureIgnoreCase)
        || lines[currentIndex].StartsWith("```"))
        {
            currentIndex++;
            if (currentIndex == lines.Length) {
                return -1;
            }
        }
        return currentIndex;
    }
}